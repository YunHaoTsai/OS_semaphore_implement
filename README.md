# OS_semaphore_implement

## GOAL
在提供的檔案中有三個程式 `p1.c`、`p2.c` 以及 `p3.c`。這三個程式都非常的簡單，分別印出不同的訊息。假設第一個被執行的檔案永遠是 `p1.c`，也就是說，你可以在 `p1.c` 建立 semaphore，而 `p2` 以及 `p3` 不用負責建立 semaphore。

你的目標是練習利用 semaphore 來同步 `p1`、`p2`、`p3` 使得執行順序是：

1. `p1` 一次
2. `p2` 一次
3. `p3` 兩次

然後一直循環下去直到迴圈結束。

也就是說，假設助教執行以下指令：

```bash
p1 & ; p2 & ; p3 &
```

你的輸出應為：

```
P1111111
P2222222
P3333333
P3333333
P1111111
P2222222
P3333333
P3333333
...
```

要達到上述的目標，你應該同步這三個程序，使得 `p1` 輸出一次，就得輪到 `p2` 輸出一次。而當 `p2` 輸出一次之後，才輪到 `p3`，而且 `p3` 必須輸出兩次之後 `p1` 才可以重新進入下一個回合。

請注意，助教也可能執行另外一種順序，如：

```bash
p1 & ; p3 & ; p2 &
```

而你的結果應該也要一樣。

---

## 編譯：
```bash
gcc -o p1 p1.c sem.c
gcc -o p2 p2.c sem.c
gcc -o p3 p3.c sem.c
```

## 執行：
```bash
./p1 &
./p2 &
./p3 &
```

---

## 邏輯：
- 為了不要讓 `p1` 偷跑，我用了 `sem_start` 並把它扣至 `-1`，讓 `p2`、`p3` 都執行到整個 semaphore 設置好後才會開始運行。

### **關於如何讓 `p3` 輸出兩次：**
1. 在 `p1` 時，讓 `sem_p1` 扣至 `-1`
2. 在 `p2` 時，讓 `sem_p3` 加至 `2`
3. `p3` 每輪皆把 `sem_p1` 加 `1`

